require "test_helper"

class GeneratedTest < Minitest::Spec
  def MyMacro(*args)
    {}
  end

  it "compiles {Schema} from intermediate and implementation, with two ends" do
    # generated by the editor or a specific DSL.
    intermediate = Inter.new({
        Inter::TaskRef(:a) => [Inter::Out(:success, :b)],
        Inter::TaskRef(:b) => [Inter::Out(:success, "End.success")],
        Inter::TaskRef("End.success", stop_event: true) => [Inter::Out(:success, nil)], # this is how the End semantic is defined.
      },
      [Inter::TaskRef("End.success")
# TODO: test with more than one End
        #, Inter::TaskRef("End.failure")
      ],
      [Inter::TaskRef(:a)] # start
    )

    # macro: {
    #   task: ,
    #   outputs: {}, connections: {},     # processed by DSL
    #   extensions: [], # invoked by the Schema
    # }

    # Implementation::Task(proc, outputs, extensions)


    _implementing = implementing
    # DISCUSS: basically, this is a thin DSL that calls Intermediate.(;)
    # you use this with a editor.
    impl = Class.new(Trailblazer::Activity::Implementation) do
      implement intermediate,
        a: _implementing.method(:a),    # TODO: :method
      # a: {task: .., outputs: .., }
        # b: MyMacro(:User, :find_by),
        "End.success" => _implementing::Failure#, [Activity::Output(implementing::Failure, :failure)]),
    end

    # merge! ==> like inheritance without inheriting methods.

    # Manu
    # merge!(MyActivity, a: "different_method")

  end
end
