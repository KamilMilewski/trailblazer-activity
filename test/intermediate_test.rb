require "test_helper"

class IntermediateTest < Minitest::Spec
  Right = Class.new#Trailblazer::Activity::Right
  Left = Class.new#Trailblazer::Activity::Right
  PassFast = Class.new#Trailblazer::Activity::Right

  Process = Trailblazer::Activity::Process
  Inter = Trailblazer::Activity::Process::Intermediate
  Activity = Trailblazer::Activity


  let(:implementing) do
    implementing = Module.new do
      extend T.def_tasks(:a, :b, :c, :d, :f, :g)
    end
    implementing::Start = Activity::Start.new(semantic: :default)
    implementing::Failure = Activity::End(:failure)
    implementing::Success = Activity::End(:success)

    implementing
  end

  it "compiles {Process} from intermediate and implementation, with two ends" do
    # generated by the editor or a specific DSL.
    # DISCUSS: is this considered DSL-independent code?
    # TODO: unique {id}
    # Intermediate shall not contain actual object references, since it might be generated.
    intermediate = Inter.new({
        Inter::TaskRef(:a) => [Inter::Out(:success, :b), Inter::Out(:failure, :c)],
        Inter::TaskRef(:b) => [Inter::Out(:success, :d), Inter::Out(:failure, :c)],
        Inter::TaskRef(:c) => [Inter::Out(:success, "End.failure"), Inter::Out(:failure, "End.failure")],
        Inter::TaskRef(:d) => [Inter::Out(:success, "End.success"), Inter::Out(:failure, "End.success")],
        Inter::TaskRef("End.success", stop_event: true) => [Inter::Out(:success, nil)], # this is how the End semantic is defined.
        Inter::TaskRef("End.failure", stop_event: true) => [Inter::Out(:failure, nil)],
      },
      [Inter::TaskRef("End.success"), Inter::TaskRef("End.failure")],
      [Inter::TaskRef(:a)] # start
    )

    Config = Trailblazer::Activity::State::Config
    a_extension_1 = ->(config:, **) { Config.send(:[]=, config, :a1, true)  }
    a_extension_2 = ->(config:, **) { Config.send(:[]=, config, :a2, :yo)   }
    b_extension_1 = ->(config:, **) { Config.send(:[]=, config, :b1, false) }

    implementation = {
      :a => Process::Implementation::Task(implementing.method(:a), [Activity::Output(Right,       :success), Activity::Output(Left, :failure)],        [a_extension_1, a_extension_2]),
      :b => Process::Implementation::Task(implementing.method(:b), [Activity::Output("B/success", :success), Activity::Output("B/failure", :failure)], [b_extension_1]),
      :c => Process::Implementation::Task(implementing.method(:c), [Activity::Output(Right,       :success), Activity::Output(Left, :failure)]),
      :d => Process::Implementation::Task(implementing.method(:d), [Activity::Output("D/success", :success), Activity::Output(Left, :failure)]),
      "End.success" => Process::Implementation::Task(implementing::Success, [Activity::Output(implementing::Success, :success)]), # DISCUSS: End has one Output, signal is itself?
      "End.failure" => Process::Implementation::Task(implementing::Failure, [Activity::Output(implementing::Failure, :failure)]),
    }

    process = Inter.(intermediate, implementation)

    cct = Trailblazer::Developer::Render::Circuit.(process: process)

    cct.must_equal %{
#<Method: #<Module:0x>.a>
 {IntermediateTest::Right} => #<Method: #<Module:0x>.b>
 {IntermediateTest::Left} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.b>
 {B/success} => #<Method: #<Module:0x>.d>
 {B/failure} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.c>
 {IntermediateTest::Right} => #<End/:failure>
 {IntermediateTest::Left} => #<End/:failure>
#<Method: #<Module:0x>.d>
 {D/success} => #<End/:success>
 {IntermediateTest::Left} => #<End/:success>
#<End/:success>

#<End/:failure>
}
    process.to_h[:outputs].inspect.must_equal %{[#<struct Trailblazer::Activity::Output signal=#<Trailblazer::Activity::End semantic=:success>, semantic=:success>, #<struct Trailblazer::Activity::Output signal=#<Trailblazer::Activity::End semantic=:failure>, semantic=:failure>]}

    process.to_h[:config].inspect.must_equal %{{:a1=>true, :a2=>:yo, :b1=>false}}
  end
end
